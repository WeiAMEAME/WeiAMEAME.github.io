<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weiameame.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="WeiAMEAME">
<meta property="og:url" content="https://weiameame.github.io/index.html">
<meta property="og:site_name" content="WeiAMEAME">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WW">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://weiameame.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>WeiAMEAME</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WeiAMEAME</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://weiameame.github.io/2022/07/06/Transactional%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeiAMEAME">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/Transactional%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Transactional注解详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-06 22:23:13" itemprop="dateCreated datePublished" datetime="2022-07-06T22:23:13+08:00">2022-07-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://weiameame.github.io/2022/07/06/hexo%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeiAMEAME">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/hexo%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">hexo命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-07-06 22:03:39 / Modified: 22:24:09" itemprop="dateCreated datePublished" datetime="2022-07-06T22:03:39+08:00">2022-07-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hexo常用命令详解<br>1、hexo init</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化根目录</span><br></pre></td></tr></table></figure>

<p>2、hexo new</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new title 新建一篇文章</span><br></pre></td></tr></table></figure>

<p>3、hexo generate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> hexo generate 可以简写成 hexo g</span><br><span class="line">该命令用于生成静态文件</span><br></pre></td></tr></table></figure>

<p>4、hexo server</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo server 命令用于启动本地服务器，一般可以简写成 hexo s</span><br><span class="line">可以加一些参数</span><br><span class="line">-p    选项，指定服务器端口，默认为 4000</span><br><span class="line">-i    选项，指定服务器 IP 地址，默认为 0.0.0.0</span><br><span class="line">-s    选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</span><br></pre></td></tr></table></figure>

<p>5、hexo deploy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy 命令用于部署网站，一般可以简写成 hexo d</span><br></pre></td></tr></table></figure>

<p>6、hexo clean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean 命令用于清理缓存文件，是一个比较常用的命令</span><br></pre></td></tr></table></figure>

<p>7、hexo –safe</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --safe 表示安全模式，用于禁用加载插件和脚本</span><br></pre></td></tr></table></figure>

<p>8、hexo –debug</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --debug 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</span><br></pre></td></tr></table></figure>

<p>9、hexo –silent</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --silent  表示静默模式，用于静默输出到终端</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://weiameame.github.io/2022/05/24/film/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeiAMEAME">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/24/film/" class="post-title-link" itemprop="url">film</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-24 14:04:49" itemprop="dateCreated datePublished" datetime="2022-05-24T14:04:49+08:00">2022-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-14 13:58:48" itemprop="dateModified" datetime="2022-05-14T13:58:48+08:00">2022-05-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="有机会要看的电影"><a href="#有机会要看的电影" class="headerlink" title="有机会要看的电影"></a>有机会要看的电影</h1><ol>
<li>那人那山那狗</li>
<li>侧耳倾听</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://weiameame.github.io/2022/05/17/kube-scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeiAMEAME">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/17/kube-scheduler/" class="post-title-link" itemprop="url">kube-scheduler</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-17 10:19:55" itemprop="dateCreated datePublished" datetime="2022-05-17T10:19:55+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-24 14:06:30" itemprop="dateModified" datetime="2022-05-24T14:06:30+08:00">2022-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h1><h2 id="1、kube-scheduler组件启动入口"><a href="#1、kube-scheduler组件启动入口" class="headerlink" title="1、kube-scheduler组件启动入口"></a>1、kube-scheduler组件启动入口</h2><p>功能：负责集群的POD资源对象的调度，根据<strong>内置或者扩展的调度算法</strong>，将未调度的POD资源对象调度到最优的工作节点上，从而更加充分地利用集群资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//pkg/scheduler/scheduler.go</span><br><span class="line">Scheduler watches for new unscheduled pods. It attempts to find</span><br><span class="line">nodes that they fit on and writes bindings back to the api server.</span><br></pre></td></tr></table></figure>

<p>根据约束和可用性为POD的调度定位</p>
<p>k8s资源注册通过go语言的导入和初始化机制来完成相关部件的资源注册过程</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.bianhb.com%2Fwp-content%2Fuploads%2Ffrc-70b03810d4e66237efc5076a96b14fef.jpeg&refer=http%3A%2F%2Fimg.bianhb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1655350049&t=13d12a6ccbc65249938a2db27a74d1c4" alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kube-scheduler入口main函数</span></span><br><span class="line"><span class="comment">//loca:k8s.io/kubernetes/cmd/kube-scheduler/scheduler.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1、初始化</span></span><br><span class="line">	command := app.NewSchedulerCommand()</span><br><span class="line">	<span class="comment">//2、执行</span></span><br><span class="line">	code := cli.Run(command)</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>构建cli命令对象，cli.Run(command)最后会调用cmd.RunE()执行具体逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulerCommand</span><span class="params">(registryOptions ...Option)</span></span> *cobra.Command &#123;</span><br><span class="line">	<span class="comment">//1、创建SchedulerOptions对象，使用默认参数初始化NewOptions</span></span><br><span class="line">	opts := options.NewOptions()</span><br><span class="line">	<span class="comment">//2、构造cli命令对象</span></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use: <span class="string">&quot;kube-scheduler&quot;</span>,</span><br><span class="line">		Long: <span class="string">`...`</span>,</span><br><span class="line">		RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> runCommand(cmd, opts, registryOptions...)</span><br><span class="line">		&#125;,</span><br><span class="line">		Args: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(arg) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%q does not take any arguments, got %q&quot;</span>, cmd.CommandPath(), args)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3、读取配置参数，并注入到需要使用的对象中</span></span><br><span class="line">	nfs := opts.Flags</span><br><span class="line">	verflag.AddFlags(nfs.FlagSet(<span class="string">&quot;global&quot;</span>))</span><br><span class="line">	globalflag.AddGlobalFlags(nfs.FlagSet(<span class="string">&quot;global&quot;</span>), cmd.Name(), logs.SkipLoggingConfigurationFlags())</span><br><span class="line">	fs := cmd.Flags()</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> nfs.FlagSets &#123;</span><br><span class="line">		fs.AddFlagSet(f)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cols, _, _ := term.TerminalSize(cmd.OutOrStdout())</span><br><span class="line">	cliflag.SetUsageAndHelpFunc(cmd, *nfs, cols)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.MarkFlagFilename(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;yaml&quot;</span>, <span class="string">&quot;yml&quot;</span>, <span class="string">&quot;json&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">&quot;Failed to mark flag filename&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>scheduler主函数运行执行关键函数调用链</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cli.Run(command)</span><br><span class="line">——RunE(cobra.Command, args)</span><br><span class="line">	——runCommand(cmd, opts, registryOptions...)</span><br><span class="line">		——Run(ctx, cc, sched)</span><br></pre></td></tr></table></figure>



<h2 id="2、Scheduler对象实例化"><a href="#2、Scheduler对象实例化" class="headerlink" title="2、Scheduler对象实例化"></a>2、Scheduler对象实例化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//loca:k8s.io/kubernetes/cmd/kube-scheduler/app/server.go</span></span><br><span class="line"><span class="comment">// Setup creates a completed config and a scheduler based on the command args and options</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setup</span><span class="params">(ctx context.Context, opts *options.Options, outOfTreeRegistryOptions ...Option)</span></span> (*schedulerserverconfig.CompletedConfig, *scheduler.Scheduler, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//读取命令行输入的配置信息</span></span><br><span class="line">	c, err := opts.Config()</span><br><span class="line">	<span class="comment">// Get the completed config 默认参数填充config</span></span><br><span class="line">	cc := c.Complete()</span><br><span class="line"></span><br><span class="line">	outOfTreeRegistry := <span class="built_in">make</span>(runtime.Registry)</span><br><span class="line">	<span class="keyword">for</span> _, option := <span class="keyword">range</span> outOfTreeRegistryOptions &#123;</span><br><span class="line">		<span class="keyword">if</span> err := option(outOfTreeRegistry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	recorderFactory := getRecorderFactory(&amp;cc)</span><br><span class="line">	completedProfiles := <span class="built_in">make</span>([]kubeschedulerconfig.KubeSchedulerProfile, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 实例化Scheduler对象</span></span><br><span class="line">	sched, err := scheduler.New(cc.Client,</span><br><span class="line">		cc.InformerFactory,</span><br><span class="line">		cc.DynInformerFactory,</span><br><span class="line">		recorderFactory,</span><br><span class="line">		ctx.Done(),</span><br><span class="line">		scheduler.WithComponentConfigVersion(cc.ComponentConfig.TypeMeta.APIVersion),</span><br><span class="line">		scheduler.WithKubeConfig(cc.KubeConfig),</span><br><span class="line">		scheduler.WithProfiles(cc.ComponentConfig.Profiles...),</span><br><span class="line">		scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class="line">		scheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),</span><br><span class="line">		scheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),</span><br><span class="line">		scheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),</span><br><span class="line">		scheduler.WithPodMaxInUnschedulablePodsDuration(cc.PodMaxInUnschedulablePodsDuration),</span><br><span class="line">		scheduler.WithExtenders(cc.ComponentConfig.Extenders...),</span><br><span class="line">		scheduler.WithParallelism(cc.ComponentConfig.Parallelism),</span><br><span class="line">		scheduler.WithBuildFrameworkCapturer(<span class="function"><span class="keyword">func</span><span class="params">(profile kubeschedulerconfig.KubeSchedulerProfile)</span></span> &#123;</span><br><span class="line">			<span class="comment">// Profiles are processed during Framework instantiation to set default plugins and configurations. Capturing them for logging</span></span><br><span class="line">			completedProfiles = <span class="built_in">append</span>(completedProfiles, profile)</span><br><span class="line">		&#125;),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := options.LogOrWriteConfig(opts.WriteConfigTo, &amp;cc.ComponentConfig, completedProfiles); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;cc, sched, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-1-Informer对象的实例化"><a href="#2-1-Informer对象的实例化" class="headerlink" title="2-1 Informer对象的实例化"></a>2-1 Informer对象的实例化</h3><p>kube-scheduler组件<strong>依赖于多个资源的Informer对象</strong>，用于监控相应资源对象的事件</p>
<p>比如基于PodInformer监控POD资源对象，当POD对象需要被创建时，scheduler监控到该事件并为此POD选择一个合适的节点进行创建</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SharedInformerFactory provides shared informers for resources in all known</span></span><br><span class="line">InformerFactory    informers.SharedInformerFactory</span><br></pre></td></tr></table></figure>

<p><strong>Informer机制</strong>简介</p>
<p>1、Reflator</p>
<p>​	监听指定k8s资源，资源变化触发Added、Updated、Deleted等事件，并将对应的资源对象存储在本地缓存<strong>DeltaFIFO</strong>中</p>
<p>2、DeltaFIFO</p>
<p>​	Delta 资源对象的操作类型 FIFO 先进先出的队列</p>
<p>3、Indexer</p>
<p>​	client-go存储资源对象并且具有<strong>索引</strong>功能的<strong>本地存储</strong>，<strong>Reflator</strong>从<strong>DeltaFIFO</strong>中消费数据存储在<strong>Indexer</strong>中。</p>
<p>​	Indexer数据与etcd中保持一致，client-go可以从Indexer中直接读取对应数据资源对象，无须远程从etcd集群中读取，降低了API server与etcd集群的压力</p>
<p><strong>优点：为了减少apiserver而设计的缓存、索引、无界队列、共享informer等机制</strong></p>
<p>疑问：这样的Informer机制是否会丢事件？丢事件的话会影响最终结果吗？</p>
<h3 id="2-2-调度算法函数的实例化"><a href="#2-2-调度算法函数的实例化" class="headerlink" title="2-2 调度算法函数的实例化"></a>2-2 调度算法函数的实例化</h3><p>v1.24.0中未找到对应的实现…..，看到的参考资料是v1.14.0版本的</p>
<h3 id="2-3-为Informer对象添加资源事件的监控"><a href="#2-3-为Informer对象添加资源事件的监控" class="headerlink" title="2-3 为Informer对象添加资源事件的监控"></a>2-3 为Informer对象添加资源事件的监控</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/pkg/scheduler/eventhandlers.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   sched *Scheduler,</span></span></span><br><span class="line"><span class="params"><span class="function">   informerFactory informers.SharedInformerFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">   dynInformerFactory dynamicinformer.DynamicSharedInformerFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">   gvkMap <span class="keyword">map</span>[framework.GVK]framework.ActionType,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>





<p>3-5步在函数func Run(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler)中</p>
<h2 id="3、运行EventBroadCaster事件管理器"><a href="#3、运行EventBroadCaster事件管理器" class="headerlink" title="3、运行EventBroadCaster事件管理器"></a>3、运行EventBroadCaster事件管理器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func Run(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler)&#123;</span><br><span class="line">...</span><br><span class="line">	cc.EventBroadcaster.StartRecordingToSink(ctx.Done())</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、运行HTTP或者HTTPS服务"><a href="#4、运行HTTP或者HTTPS服务" class="headerlink" title="4、运行HTTP或者HTTPS服务"></a>4、运行HTTP或者HTTPS服务</h2><p>健康检查、监控指标、性能分析等服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup healthz checks.</span></span><br><span class="line"><span class="keyword">var</span> checks []healthz.HealthChecker</span><br><span class="line"><span class="keyword">if</span> cc.ComponentConfig.LeaderElection.LeaderElect &#123;</span><br><span class="line">   checks = <span class="built_in">append</span>(checks, cc.LeaderElection.WatchDog)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">// Start up the healthz server.</span></span><br><span class="line"><span class="keyword">if</span> cc.SecureServing != <span class="literal">nil</span> &#123;</span><br><span class="line">    handler := buildHandlerChain(newHealthzAndMetricsHandler(&amp;cc.ComponentConfig, cc.InformerFactory, isLeader, checks...), cc.Authentication.Authenticator, cc.Authorization.Authorizer)</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle stoppedCh and listenerStoppedCh returned by c.SecureServing.Serve</span></span><br><span class="line">    <span class="keyword">if</span> _, _, err := cc.SecureServing.Serve(handler, <span class="number">0</span>, ctx.Done()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// fail early for secure handlers, removing the old error loop from above</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to start secure server: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、启动所有的informers，并进行LeaderElection"><a href="#5、启动所有的informers，并进行LeaderElection" class="headerlink" title="5、启动所有的informers，并进行LeaderElection"></a>5、启动所有的informers，并进行LeaderElection</h2><p>选择一个节点执行<strong>sched.Run(ctx)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start all informers.</span></span><br><span class="line">cc.InformerFactory.Start(ctx.Done())</span><br><span class="line"><span class="comment">// DynInformerFactory can be nil in tests.</span></span><br><span class="line"><span class="keyword">if</span> cc.DynInformerFactory != <span class="literal">nil</span> &#123;</span><br><span class="line">   cc.DynInformerFactory.Start(ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度前先进行同步操作</span></span><br><span class="line">cc.InformerFactory.WaitForCacheSync(ctx.Done())</span><br><span class="line"><span class="comment">// DynInformerFactory can be nil in tests.</span></span><br><span class="line"><span class="keyword">if</span> cc.DynInformerFactory != <span class="literal">nil</span> &#123;</span><br><span class="line">   cc.DynInformerFactory.WaitForCacheSync(ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果启动了选举操作，则会进行Leader选举，通过这种方式调用sched.Run(ctx)</span></span><br><span class="line"><span class="keyword">if</span> cc.LeaderElection != <span class="literal">nil</span> &#123;</span><br><span class="line">   cc.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;</span><br><span class="line">      <span class="comment">//当前节点位于Leader，会触发此处的回调</span></span><br><span class="line">      OnStartedLeading: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">         <span class="built_in">close</span>(waitingForLeader)</span><br><span class="line">         sched.Run(ctx)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//其他节点不进行调度</span></span><br><span class="line">      OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// We were asked to terminate. Exit 0.</span></span><br><span class="line">            klog.InfoS(<span class="string">&quot;Requested to terminate, exiting&quot;</span>)</span><br><span class="line">            os.Exit(<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// We lost the lock.</span></span><br><span class="line">            klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Leaderelection lost&quot;</span>)</span><br><span class="line">            klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   leaderElector, err := leaderelection.NewLeaderElector(*cc.LeaderElection)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;couldn&#x27;t create leader elector: %v&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//启动选举</span></span><br><span class="line">   leaderElector.Run(ctx)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;lost lease&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不进行选举，直接进行调度</span></span><br><span class="line"><span class="built_in">close</span>(waitingForLeader)</span><br><span class="line">sched.Run(ctx)</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;finished without leader elect&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="6、开始调度"><a href="#6、开始调度" class="headerlink" title="6、开始调度"></a>6、开始调度</h2><h3 id="6-1-主要调用函数链"><a href="#6-1-主要调用函数链" class="headerlink" title="6-1 主要调用函数链"></a>6-1 主要调用函数链</h3><p><img src="https://s2.loli.net/2022/05/19/1eNW2LdIhmCsEX9.png"></p>
<h3 id="6-2-相关数据结构说明"><a href="#6-2-相关数据结构说明" class="headerlink" title="6-2 相关数据结构说明"></a>6-2 相关数据结构说明</h3><h4 id="6-2-1-Scheduler"><a href="#6-2-1-Scheduler" class="headerlink" title="6-2-1 Scheduler"></a>6-2-1 Scheduler</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">   Cache internalcache.Cache</span><br><span class="line">   Extenders []framework.Extender</span><br><span class="line">   <span class="comment">// 从阻塞队列中获取待调度的Pod</span></span><br><span class="line">   NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span></span> *framework.QueuedPodInfo</span><br><span class="line">   Error <span class="function"><span class="keyword">func</span><span class="params">(*framework.QueuedPodInfo, <span class="type">error</span>)</span></span></span><br><span class="line">   <span class="comment">// 调度函数</span></span><br><span class="line">   SchedulePod <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod)</span></span> (ScheduleResult, <span class="type">error</span>)</span><br><span class="line">   <span class="comment">// 停止调度</span></span><br><span class="line">   StopEverything &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   <span class="comment">//阻塞队列</span></span><br><span class="line">   SchedulingQueue internalqueue.SchedulingQueue</span><br><span class="line">   <span class="comment">//暂时还没研究</span></span><br><span class="line">   Profiles profile.Map</span><br><span class="line">   client clientset.Interface</span><br><span class="line">   nodeInfoSnapshot *internalcache.Snapshot</span><br><span class="line">   percentageOfNodesToScore <span class="type">int32</span></span><br><span class="line">   nextStartNodeIndex <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-FilterPlugin-预选调度算法接口"><a href="#6-2-2-FilterPlugin-预选调度算法接口" class="headerlink" title="6-2-2 FilterPlugin 预选调度算法接口"></a>6-2-2 FilterPlugin 预选调度算法接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FilterPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   Filter(ctx context.Context, state *CycleState, pod *v1.Pod, nodeInfo *NodeInfo) *Status</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-2-3-Extender-扩展调度算法接口"><a href="#6-2-3-Extender-扩展调度算法接口" class="headerlink" title="6-2-3 Extender 扩展调度算法接口?"></a>6-2-3 Extender 扩展调度算法接口?</h4><p>还没仔细研究，但是它既有Filter 也有Prioritize，也就是既有预选，也有优选</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">type Extender interface &#123;</span><br><span class="line"></span><br><span class="line">   Name() string</span><br><span class="line"></span><br><span class="line">   Filter(pod *v1.Pod, nodes []*v1.Node) (filteredNodes []*v1.Node, failedNodesMap extenderv1.FailedNodesMap, failedAndUnresolvable extenderv1.FailedNodesMap, err error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Prioritize(pod *v1.Pod, nodes []*v1.Node) (hostPriorities *extenderv1.HostPriorityList, weight int64, err error)</span><br><span class="line"></span><br><span class="line">   Bind(binding *v1.Binding) error</span><br><span class="line"></span><br><span class="line">   IsBinder() bool</span><br><span class="line"></span><br><span class="line">   IsInterested(pod *v1.Pod) bool</span><br><span class="line"></span><br><span class="line">   ProcessPreemption(</span><br><span class="line">      pod *v1.Pod,</span><br><span class="line">      nodeNameToVictims map[string]*extenderv1.Victims,</span><br><span class="line">      nodeInfos NodeInfoLister,</span><br><span class="line">   ) (map[string]*extenderv1.Victims, error)</span><br><span class="line"></span><br><span class="line">   SupportsPreemption() bool</span><br><span class="line"></span><br><span class="line">   IsIgnorable() bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-2-4-ScorePlugin-优选算法接口"><a href="#6-2-4-ScorePlugin-优选算法接口" class="headerlink" title="6-2-4 ScorePlugin 优选算法接口"></a>6-2-4 ScorePlugin 优选算法接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ScorePlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   <span class="comment">//计算pod在node上的得分</span></span><br><span class="line">   Score(ctx context.Context, state *CycleState, p *v1.Pod, nodeName <span class="type">string</span>) (<span class="type">int64</span>, *Status)</span><br><span class="line">   ScoreExtensions() ScoreExtensions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-2-5-PostFilterPlugin-抢占算法接口"><a href="#6-2-5-PostFilterPlugin-抢占算法接口" class="headerlink" title="6-2-5 PostFilterPlugin  抢占算法接口"></a>6-2-5 PostFilterPlugin  抢占算法接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type PostFilterPlugin interface &#123;</span><br><span class="line">   Plugin</span><br><span class="line"></span><br><span class="line">   PostFilter(ctx context.Context, state *CycleState, pod *v1.Pod, filteredNodeStatusMap NodeToStatusMap) (*PostFilterResult, *Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-调度过程逻辑"><a href="#6-3-调度过程逻辑" class="headerlink" title="6-3 调度过程逻辑"></a>6-3 调度过程逻辑</h3><h4 id="6-3-1-调度前的性能优化"><a href="#6-3-1-调度前的性能优化" class="headerlink" title="6-3-1 调度前的性能优化"></a>6-3-1 调度前的性能优化</h4><p>PercentageOfNodesToScore 一旦发现一定数量的可用节点(占所有节点的百分比),调度器会停止搜索更多的可用节点，默认0%，表示不启用此功能。</p>
<p>当集群中数量上千个及以上开启此参数可以提高性能</p>
<h4 id="6-3-2-调度关键函数schedulePod"><a href="#6-3-2-调度关键函数schedulePod" class="headerlink" title="6-3-2 调度关键函数schedulePod"></a>6-3-2 调度关键函数schedulePod</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">func (sched *Scheduler) schedulePod(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) (result ScheduleResult, err error) &#123;</span><br><span class="line">   trace := utiltrace.New(&quot;Scheduling&quot;, utiltrace.Field&#123;Key: &quot;namespace&quot;, Value: pod.Namespace&#125;, utiltrace.Field&#123;Key: &quot;name&quot;, Value: pod.Name&#125;)</span><br><span class="line">   defer trace.LogIfLong(100 * time.Millisecond)</span><br><span class="line"></span><br><span class="line">   if err := sched.Cache.UpdateSnapshot(sched.nodeInfoSnapshot); err != nil &#123;</span><br><span class="line">      return result, err</span><br><span class="line">   &#125;</span><br><span class="line">   trace.Step(&quot;Snapshotting scheduler cache and node infos done&quot;)</span><br><span class="line"></span><br><span class="line">   if sched.nodeInfoSnapshot.NumNodes() == 0 &#123;</span><br><span class="line">      return result, ErrNoNodesAvailable</span><br><span class="line">   &#125;</span><br><span class="line">   //预选调度算法</span><br><span class="line">   feasibleNodes, diagnosis, err := sched.findNodesThatFitPod(ctx, fwk, state, pod)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return result, err</span><br><span class="line">   &#125;</span><br><span class="line">   trace.Step(&quot;Computing predicates done&quot;)</span><br><span class="line"></span><br><span class="line">   if len(feasibleNodes) == 0 &#123;</span><br><span class="line">      return result, &amp;framework.FitError&#123;</span><br><span class="line">         Pod:         pod,</span><br><span class="line">         NumAllNodes: sched.nodeInfoSnapshot.NumNodes(),</span><br><span class="line">         Diagnosis:   diagnosis,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // When only one node after predicate, just use it.</span><br><span class="line">   if len(feasibleNodes) == 1 &#123;</span><br><span class="line">      return ScheduleResult&#123;</span><br><span class="line">         SuggestedHost:  feasibleNodes[0].Name,</span><br><span class="line">         EvaluatedNodes: 1 + len(diagnosis.NodeToStatusMap),</span><br><span class="line">         FeasibleNodes:  1,</span><br><span class="line">      &#125;, nil</span><br><span class="line">   &#125;</span><br><span class="line">	//对预选节点集进行优选调度</span><br><span class="line">   priorityList, err := prioritizeNodes(ctx, sched.Extenders, fwk, state, pod, feasibleNodes)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return result, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   host, err := selectHost(priorityList)</span><br><span class="line">   trace.Step(&quot;Prioritizing done&quot;)</span><br><span class="line"></span><br><span class="line">   return ScheduleResult&#123;</span><br><span class="line">      SuggestedHost:  host,</span><br><span class="line">      EvaluatedNodes: len(feasibleNodes) + len(diagnosis.NodeToStatusMap),</span><br><span class="line">      FeasibleNodes:  len(feasibleNodes),</span><br><span class="line">   &#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-3-预选调度"><a href="#6-3-3-预选调度" class="headerlink" title="6-3-3 预选调度"></a>6-3-3 预选调度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">func (sched *Scheduler) findNodesThatFitPod(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) ([]*v1.Node, framework.Diagnosis, error) &#123;</span><br><span class="line">   diagnosis := framework.Diagnosis&#123;</span><br><span class="line">      NodeToStatusMap:      make(framework.NodeToStatusMap),</span><br><span class="line">      UnschedulablePlugins: sets.NewString(),</span><br><span class="line">   &#125;</span><br><span class="line">   // 调度前处理器，可以做一些校验工作</span><br><span class="line">   preRes, s := fwk.RunPreFilterPlugins(ctx, state, pod)</span><br><span class="line">   allNodes, err := sched.nodeInfoSnapshot.NodeInfos().List()</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return nil, diagnosis, err</span><br><span class="line">   &#125;</span><br><span class="line">   if !s.IsSuccess() &#123;</span><br><span class="line">      if !s.IsUnschedulable() &#123;</span><br><span class="line">         return nil, diagnosis, s.AsError()</span><br><span class="line">      &#125;</span><br><span class="line">      for _, n := range allNodes &#123;</span><br><span class="line">         diagnosis.NodeToStatusMap[n.Node().Name] = s</span><br><span class="line">      &#125;</span><br><span class="line">      if s.FailedPlugin() != &quot;&quot; &#123;</span><br><span class="line">         diagnosis.UnschedulablePlugins.Insert(s.FailedPlugin())</span><br><span class="line">      &#125;</span><br><span class="line">      return nil, diagnosis, nil</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if len(pod.Status.NominatedNodeName) &gt; 0 &#123;</span><br><span class="line">      feasibleNodes, err := sched.evaluateNominatedNode(ctx, pod, fwk, state, diagnosis)</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         klog.ErrorS(err, &quot;Evaluation failed on nominated node&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;node&quot;, pod.Status.NominatedNodeName)</span><br><span class="line">      &#125;</span><br><span class="line">      if len(feasibleNodes) != 0 &#123;</span><br><span class="line">         return feasibleNodes, diagnosis, nil</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   nodes := allNodes</span><br><span class="line">   if !preRes.AllNodes() &#123;</span><br><span class="line">      nodes = make([]*framework.NodeInfo, 0, len(preRes.NodeNames))</span><br><span class="line">      for n := range preRes.NodeNames &#123;</span><br><span class="line">         nInfo, err := sched.nodeInfoSnapshot.NodeInfos().Get(n)</span><br><span class="line">         if err != nil &#123;</span><br><span class="line">            return nil, diagnosis, err</span><br><span class="line">         &#125;</span><br><span class="line">         nodes = append(nodes, nInfo)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //遍历FilterPlugin进行预选</span><br><span class="line">   feasibleNodes, err := sched.findNodesThatPassFilters(ctx, fwk, state, pod, diagnosis, nodes)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return nil, diagnosis, err</span><br><span class="line">   &#125;</span><br><span class="line">	//遍历extender进行预选，这里只调用了extender的Filter函数进行预选</span><br><span class="line">   feasibleNodes, err = findNodesThatPassExtenders(sched.Extenders, pod, feasibleNodes, diagnosis.NodeToStatusMap)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return nil, diagnosis, err</span><br><span class="line">   &#125;</span><br><span class="line">   return feasibleNodes, diagnosis, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sched.findNodesThatPassFilters(ctx, fwk, state, pod, diagnosis, nodes)</span><br><span class="line"></span><br><span class="line">checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   nodeInfo := nodes[(sched.nextStartNodeIndex+i)%<span class="built_in">len</span>(nodes)]</span><br><span class="line">   status := fwk.RunFilterPluginsWithNominatedPods(ctx, state, pod, nodeInfo)</span><br><span class="line">   <span class="keyword">if</span> status.Code() == framework.Error &#123;</span><br><span class="line">      errCh.SendErrorWithCancel(status.AsError(), cancel)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> status.IsSuccess() &#123;</span><br><span class="line">      length := atomic.AddInt32(&amp;feasibleNodesLen, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> length &gt; numNodesToFind &#123;</span><br><span class="line">         cancel()</span><br><span class="line">         atomic.AddInt32(&amp;feasibleNodesLen, <span class="number">-1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         feasibleNodes[length<span class="number">-1</span>] = nodeInfo.Node()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      statusesLock.Lock()</span><br><span class="line">      diagnosis.NodeToStatusMap[nodeInfo.Node().Name] = status</span><br><span class="line">      diagnosis.UnschedulablePlugins.Insert(status.FailedPlugin())</span><br><span class="line">      statusesLock.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并发执行</span></span><br><span class="line">fwk.Parallelizer().Until(ctx, <span class="built_in">len</span>(nodes), checkNode)</span><br></pre></td></tr></table></figure>



<p><strong>为什么要运行两次所有的预选调度算法呢？</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *frameworkImpl)</span></span> RunFilterPluginsWithNominatedPods(ctx context.Context, state *framework.CycleState, pod *v1.Pod, info *framework.NodeInfo) *framework.Status &#123;</span><br><span class="line">	<span class="keyword">var</span> status *framework.Status</span><br><span class="line"></span><br><span class="line">	podsAdded := <span class="literal">false</span></span><br><span class="line">	<span class="comment">//与亲和性调度有关</span></span><br><span class="line">	<span class="comment">//addNominatedPods会找到当前调度队列中大于或者等于当前POD资源对象的NominatedPods，并加入到info中</span></span><br><span class="line">	<span class="comment">//NominatedPods表示已经分配到节点上但是还没有起来的POD，这类POD在其他POD资源从NODE中删除了才会实际调度</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		stateToUse := state</span><br><span class="line">		nodeInfoToUse := info</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">			podsAdded, stateToUse, nodeInfoToUse, err = addNominatedPods(ctx, f, pod, state, info)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> framework.AsStatus(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !podsAdded || !status.IsSuccess() &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		statusMap := f.RunFilterPlugins(ctx, stateToUse, pod, nodeInfoToUse)</span><br><span class="line">		status = statusMap.Merge()</span><br><span class="line">		<span class="keyword">if</span> !status.IsSuccess() &amp;&amp; !status.IsUnschedulable() &#123;</span><br><span class="line">			<span class="keyword">return</span> status</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-4-优选调度"><a href="#6-3-4-优选调度" class="headerlink" title="6-3-4 优选调度"></a>6-3-4 优选调度</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prioritizeNodes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">   extenders []framework.Extender,</span></span></span><br><span class="line"><span class="params"><span class="function">   fwk framework.Framework,</span></span></span><br><span class="line"><span class="params"><span class="function">   state *framework.CycleState,</span></span></span><br><span class="line"><span class="params"><span class="function">   pod *v1.Pod,</span></span></span><br><span class="line"><span class="params"><span class="function">   nodes []*v1.Node,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (framework.NodeScoreList, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// 没有任何计分插件，直接给个1分返回</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(extenders) == <span class="number">0</span> &amp;&amp; !fwk.HasScorePlugins() &#123;</span><br><span class="line">      result := <span class="built_in">make</span>(framework.NodeScoreList, <span class="number">0</span>, <span class="built_in">len</span>(nodes))</span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">         result = <span class="built_in">append</span>(result, framework.NodeScore&#123;</span><br><span class="line">            Name:  nodes[i].Name,</span><br><span class="line">            Score: <span class="number">1</span>,</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 前处理插件</span></span><br><span class="line">   preScoreStatus := fwk.RunPreScorePlugins(ctx, state, pod, nodes)</span><br><span class="line">   <span class="keyword">if</span> !preScoreStatus.IsSuccess() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, preScoreStatus.AsError()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Score插件运行计分</span></span><br><span class="line">   scoresMap, scoreStatus := fwk.RunScorePlugins(ctx, state, pod, nodes)</span><br><span class="line">   <span class="keyword">if</span> !scoreStatus.IsSuccess() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, scoreStatus.AsError()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 积分求和</span></span><br><span class="line">   result := <span class="built_in">make</span>(framework.NodeScoreList, <span class="number">0</span>, <span class="built_in">len</span>(nodes))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">      result = <span class="built_in">append</span>(result, framework.NodeScore&#123;Name: nodes[i].Name, Score: <span class="number">0</span>&#125;)</span><br><span class="line">      <span class="keyword">for</span> j := <span class="keyword">range</span> scoresMap &#123;</span><br><span class="line">         result[i].Score += scoresMap[j][i].Score</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//extender的Score计分</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(extenders) != <span class="number">0</span> &amp;&amp; nodes != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">      <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">      combinedScores := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>, <span class="built_in">len</span>(nodes))</span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> extenders &#123;</span><br><span class="line">         <span class="keyword">if</span> !extenders[i].IsInterested(pod) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         wg.Add(<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(extIndex <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            metrics.SchedulerGoroutines.WithLabelValues(metrics.PrioritizingExtender).Inc()</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">               metrics.SchedulerGoroutines.WithLabelValues(metrics.PrioritizingExtender).Dec()</span><br><span class="line">               wg.Done()</span><br><span class="line">            &#125;()</span><br><span class="line">            prioritizedList, weight, err := extenders[extIndex].Prioritize(pod, nodes)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">               klog.V(<span class="number">5</span>).InfoS(<span class="string">&quot;Failed to run extender&#x27;s priority function. No score given by this extender.&quot;</span>, <span class="string">&quot;error&quot;</span>, err, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;extender&quot;</span>, extenders[extIndex].Name())</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            mu.Lock()</span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> *prioritizedList &#123;</span><br><span class="line">               host, score := (*prioritizedList)[i].Host, (*prioritizedList)[i].Score</span><br><span class="line">               <span class="keyword">if</span> klogV.Enabled() &#123;</span><br><span class="line">                  klogV.InfoS(<span class="string">&quot;Extender scored node for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;extender&quot;</span>, extenders[extIndex].Name(), <span class="string">&quot;node&quot;</span>, host, <span class="string">&quot;score&quot;</span>, score)</span><br><span class="line">               &#125;</span><br><span class="line">               combinedScores[host] += score * weight</span><br><span class="line">            &#125;</span><br><span class="line">            mu.Unlock()</span><br><span class="line">         &#125;(i)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 计算含权积分</span></span><br><span class="line">      wg.Wait()</span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">         result[i].Score += combinedScores[result[i].Name] * (framework.MaxNodeScore / extenderv1.MaxExtenderPriority)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> klogV.Enabled() &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">         klogV.InfoS(<span class="string">&quot;Calculated node&#x27;s final score for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;node&quot;</span>, result[i].Name, <span class="string">&quot;score&quot;</span>, result[i].Score)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-5-最终抉择"><a href="#6-3-5-最终抉择" class="headerlink" title="6-3-5 最终抉择"></a>6-3-5 最终抉择</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NodeScoreList是一个大顶堆？</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectHost</span><span class="params">(nodeScoreList framework.NodeScoreList)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(nodeScoreList) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;empty priorityList&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   maxScore := nodeScoreList[<span class="number">0</span>].Score</span><br><span class="line">   selected := nodeScoreList[<span class="number">0</span>].Name</span><br><span class="line">   cntOfMaxScore := <span class="number">1</span></span><br><span class="line">   <span class="comment">//如果相同得分则随机选择一个，v1.14.0用的是round-robin轮询方式选择一个最佳节点</span></span><br><span class="line">   <span class="keyword">for</span> _, ns := <span class="keyword">range</span> nodeScoreList[<span class="number">1</span>:] &#123;</span><br><span class="line">      <span class="keyword">if</span> ns.Score &gt; maxScore &#123;</span><br><span class="line">         maxScore = ns.Score</span><br><span class="line">         selected = ns.Name</span><br><span class="line">         cntOfMaxScore = <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ns.Score == maxScore &#123;</span><br><span class="line">         cntOfMaxScore++</span><br><span class="line">         <span class="keyword">if</span> rand.Intn(cntOfMaxScore) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Replace the candidate with probability of 1/cntOfMaxScore</span></span><br><span class="line">            selected = ns.Name</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> selected, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-4-抢占机制"><a href="#6-4-抢占机制" class="headerlink" title="6-4 抢占机制"></a>6-4 抢占机制</h3><p>高优先级的POD没有合适的节点时，scheduler会尝试抢占低优先级的POD节点。</p>
<p>机制：低优先级POD会被节点驱逐，再让高优先级的POD运行，被驱逐的POD会重新进入调度队列等待再次进行调度</p>
<p>NominatedPods表示已经被该node提名的，<strong>期望调度在该node上</strong>的，但是又<strong>还没最终成功调度</strong>过来的Pods</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口函数</span></span><br><span class="line"><span class="comment">//k8s.io/kubernetes/pkg/scheduler/schedule_one.go  scheduleOne()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fitError, ok := err.(*framework.FitError); ok &#123;</span><br><span class="line">   <span class="keyword">if</span> !fwk.HasPostFilterPlugins() &#123;</span><br><span class="line">      klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;No PostFilter plugins are registered, so no preemption will be performed&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result, status := fwk.RunPostFilterPlugins(ctx, state, pod, fitError.Diagnosis.NodeToStatusMap)</span><br><span class="line">      <span class="keyword">if</span> status.Code() == framework.Error &#123;</span><br><span class="line">         klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Status after running PostFilter plugins for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;status&quot;</span>, status)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         fitError.Diagnosis.PostFilterMsg = status.Message()</span><br><span class="line">         klog.V(<span class="number">5</span>).InfoS(<span class="string">&quot;Status after running PostFilter plugins for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;status&quot;</span>, status)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">         nominatingInfo = result.NominatingInfo</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   metrics.PodUnschedulable(fwk.ProfileName(), metrics.SinceInSeconds(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面就是正式的调度过程</span></span><br></pre></td></tr></table></figure>



<p><strong>默认抢占算法</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *DefaultPreemption)</span></span> PostFilter(ctx context.Context, state *framework.CycleState, pod *v1.Pod, m framework.NodeToStatusMap) (*framework.PostFilterResult, *framework.Status) &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      metrics.PreemptionAttempts.Inc()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   pe := preemption.Evaluator&#123;</span><br><span class="line">      PluginName: names.DefaultPreemption,</span><br><span class="line">      Handler:    pl.fh,</span><br><span class="line">      PodLister:  pl.podLister,</span><br><span class="line">      PdbLister:  pl.pdbLister,</span><br><span class="line">      State:      state,</span><br><span class="line">      Interface:  pl,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   result, status := pe.Preempt(ctx, pod, m)</span><br><span class="line">   <span class="keyword">if</span> status.Message() != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result, framework.NewStatus(status.Code(), <span class="string">&quot;preemption: &quot;</span>+status.Message())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result, status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认抢占算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ev *Evaluator)</span></span> Preempt(ctx context.Context, pod *v1.Pod, m framework.NodeToStatusMap) (*framework.PostFilterResult, *framework.Status) &#123;</span><br><span class="line">	<span class="comment">// 0) 向API Server发送请求，更新调度失败的Pod资源对象数据</span></span><br><span class="line">	podNamespace, podName := pod.Namespace, pod.Name</span><br><span class="line">	pod, err := ev.PodLister.Pods(pod.Namespace).Get(pod.Name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">&quot;Getting the updated preemptor pod object&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KRef(podNamespace, podName))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, framework.AsStatus(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1) 确保当前pod有资格抢占其他pod资源对象所在的节点</span></span><br><span class="line">	<span class="keyword">if</span> ok, msg := ev.PodEligibleToPreemptOthers(pod, m[pod.Status.NominatedNodeName]); !ok &#123;</span><br><span class="line">		klog.V(<span class="number">5</span>).InfoS(<span class="string">&quot;Pod is not eligible for preemption&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;reason&quot;</span>, msg)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, framework.NewStatus(framework.Unschedulable, msg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2) 搜索候选节点</span></span><br><span class="line">	candidates, nodeToStatusMap, err := ev.findCandidates(ctx, pod, m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(candidates) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, framework.AsStatus(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return a FitError only when there are no candidates that fit the pod.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(candidates) == <span class="number">0</span> &#123;</span><br><span class="line">		fitError := &amp;framework.FitError&#123;</span><br><span class="line">			Pod:         pod,</span><br><span class="line">			NumAllNodes: <span class="built_in">len</span>(nodeToStatusMap),</span><br><span class="line">			Diagnosis: framework.Diagnosis&#123;</span><br><span class="line">				NodeToStatusMap: nodeToStatusMap,</span><br><span class="line">				<span class="comment">// Leave FailedPlugins as nil as it won&#x27;t be used on moving Pods.</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Specify nominatedNodeName to clear the pod&#x27;s nominatedNodeName status, if applicable.</span></span><br><span class="line">		<span class="keyword">return</span> framework.NewPostFilterResultWithNominatedNode(<span class="string">&quot;&quot;</span>), framework.NewStatus(framework.Unschedulable, fitError.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3) 扩展插件调用</span></span><br><span class="line">	candidates, status := ev.callExtenders(pod, candidates)</span><br><span class="line">	<span class="keyword">if</span> !status.IsSuccess() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4) 选择一个最好的调度节点</span></span><br><span class="line">	bestCandidate := ev.SelectCandidate(candidates)</span><br><span class="line">	<span class="keyword">if</span> bestCandidate == <span class="literal">nil</span> || <span class="built_in">len</span>(bestCandidate.Name()) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, framework.NewStatus(framework.Unschedulable, <span class="string">&quot;no candidate node for preemption&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5)抢占前的准备工作.</span></span><br><span class="line">    <span class="comment">//要被驱逐的pod如果还在调度队列中，拒绝调度此类pod</span></span><br><span class="line">    <span class="comment">//清除低优先级的NominatedPods，让scheduler重新调度</span></span><br><span class="line">	<span class="keyword">if</span> status := ev.prepareCandidate(bestCandidate, pod, ev.PluginName); !status.IsSuccess() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> framework.NewPostFilterResultWithNominatedNode(bestCandidate.Name()), framework.NewStatus(framework.Success)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）确保当前pod有资格抢占其他pod资源对象所在的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *DefaultPreemption)</span></span> PodEligibleToPreemptOthers(pod *v1.Pod, nominatedNodeStatus *framework.Status) (<span class="type">bool</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="comment">//抢占策略为Never表示不发生抢占</span></span><br><span class="line">    <span class="keyword">if</span> pod.Spec.PreemptionPolicy != <span class="literal">nil</span> &amp;&amp; *pod.Spec.PreemptionPolicy == v1.PreemptNever &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>, fmt.Sprint(<span class="string">&quot;not eligible due to preemptionPolicy=Never.&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   nodeInfos := pl.fh.SnapshotSharedLister().NodeInfos()</span><br><span class="line">   nomNodeName := pod.Status.NominatedNodeName</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(nomNodeName) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// node状态为无法调度</span></span><br><span class="line">      <span class="keyword">if</span> nominatedNodeStatus.Code() == framework.UnschedulableAndUnresolvable &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">//遍历node上的所有Pod对象，如果有优先级小于待调度的Pod对象并且处于终止状态，则返回false，不发生抢占</span></span><br><span class="line">      <span class="keyword">if</span> nodeInfo, _ := nodeInfos.Get(nomNodeName); nodeInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">         podPriority := corev1helpers.PodPriority(pod)</span><br><span class="line">         <span class="keyword">for</span> _, p := <span class="keyword">range</span> nodeInfo.Pods &#123;</span><br><span class="line">            <span class="keyword">if</span> p.Pod.DeletionTimestamp != <span class="literal">nil</span> &amp;&amp; corev1helpers.PodPriority(p.Pod) &lt; podPriority &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>, fmt.Sprint(<span class="string">&quot;not eligible due to a terminating pod on the nominated node.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）搜索候选调度节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ev *Evaluator)</span></span> findCandidates(ctx context.Context, pod *v1.Pod, m framework.NodeToStatusMap) ([]Candidate, framework.NodeToStatusMap, <span class="type">error</span>) &#123;</span><br><span class="line">   allNodes, err := ev.Handler.SnapshotSharedLister().NodeInfos().List()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(allNodes) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;no nodes available&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//从预选调度失败的节点中尝试找到能够调度的节点列表，潜在的节点列表</span></span><br><span class="line">   <span class="comment">//我的理解：预选失败可能是因为node上运行的pod太多了，因此抢占的时候可以驱逐此node上的部分pod，这部分pod可能满足驱逐条件的概率更大</span></span><br><span class="line">   potentialNodes, unschedulableNodeStatus := nodesWherePreemptionMightHelp(allNodes, m)</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(potentialNodes) == <span class="number">0</span> &#123;</span><br><span class="line">      klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Preemption will not help schedule pod on any node&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">      <span class="keyword">if</span> err := util.ClearNominatedNodeName(ev.Handler.ClientSet(), pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         klog.ErrorS(err, <span class="string">&quot;Cannot clear &#x27;NominatedNodeName&#x27; field of pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, unschedulableNodeStatus, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   pdbs, err := getPodDisruptionBudgets(ev.PdbLister)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//随机选取一个偏移量，及需要获取的候选pod数量</span></span><br><span class="line">   offset, numCandidates := ev.GetOffsetAndNumCandidates(<span class="type">int32</span>(<span class="built_in">len</span>(potentialNodes)))</span><br><span class="line">   <span class="keyword">if</span> klogV := klog.V(<span class="number">5</span>); klogV.Enabled() &#123;</span><br><span class="line">      <span class="keyword">var</span> sample []<span class="type">string</span></span><br><span class="line">      <span class="keyword">for</span> i := offset; i &lt; offset+<span class="number">10</span> &amp;&amp; i &lt; <span class="type">int32</span>(<span class="built_in">len</span>(potentialNodes)); i++ &#123;</span><br><span class="line">         sample = <span class="built_in">append</span>(sample, potentialNodes[i].Node().Name)</span><br><span class="line">      &#125;</span><br><span class="line">      klogV.InfoS(<span class="string">&quot;Selecting candidates from a pool of nodes&quot;</span>, <span class="string">&quot;potentialNodesCount&quot;</span>, <span class="built_in">len</span>(potentialNodes), <span class="string">&quot;offset&quot;</span>, offset, <span class="string">&quot;sampleLength&quot;</span>, <span class="built_in">len</span>(sample), <span class="string">&quot;sample&quot;</span>, sample, <span class="string">&quot;candidates&quot;</span>, numCandidates)</span><br><span class="line">   &#125;</span><br><span class="line">   candidates, nodeStatuses, err := ev.DryRunPreemption(ctx, pod, potentialNodes, pdbs, offset, numCandidates)</span><br><span class="line">   <span class="keyword">for</span> node, nodeStatus := <span class="keyword">range</span> unschedulableNodeStatus &#123;</span><br><span class="line">      nodeStatuses[node] = nodeStatus</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> candidates, nodeStatuses, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//numCandidates 候选人的数量 pl.args.MinCandidateNodesAbsolute &lt; numCandidates &lt; numNodes</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *DefaultPreemption)</span></span> GetOffsetAndNumCandidates(numNodes <span class="type">int32</span>) (<span class="type">int32</span>, <span class="type">int32</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> rand.Int31n(numNodes), pl.calculateNumCandidates(numNodes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取优先调度pod的PodPriority</span></span><br><span class="line"><span class="comment">获取所有比优先调度pod的PodPriority更小的pod，并执行removepod函数删除这些pod</span></span><br><span class="line"><span class="comment">在上一步删除Pod之后，再在node上对优先调度pod进行预选</span></span><br><span class="line"><span class="comment">对前两步删除pod，检查是否会导致pod的数量小于pdb的min-avilable，分为会和不会两类</span></span><br><span class="line"><span class="comment">先对因为pdb限制不能删除的pod执行reprievePod函数（reprievePod函数：先add pod再执行预选，如果预选失败，则再remove pod）</span></span><br><span class="line"><span class="comment">再对没有pdb限制或者pdb允许删除的pod执行reprievePod函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ev *Evaluator)</span></span> DryRunPreemption(ctx context.Context, pod *v1.Pod, potentialNodes []*framework.NodeInfo,</span><br><span class="line">   pdbs []*policy.PodDisruptionBudget, offset <span class="type">int32</span>, numCandidates <span class="type">int32</span>) ([]Candidate, framework.NodeToStatusMap, <span class="type">error</span>) &#123;</span><br><span class="line">   fh := ev.Handler</span><br><span class="line">   nonViolatingCandidates := newCandidateList(numCandidates)</span><br><span class="line">   violatingCandidates := newCandidateList(numCandidates)</span><br><span class="line">   parallelCtx, cancel := context.WithCancel(ctx)</span><br><span class="line">   nodeStatuses := <span class="built_in">make</span>(framework.NodeToStatusMap)</span><br><span class="line">   <span class="keyword">var</span> statusesLock sync.Mutex</span><br><span class="line">   <span class="keyword">var</span> errs []<span class="type">error</span></span><br><span class="line">   checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      nodeInfoCopy := potentialNodes[(<span class="type">int</span>(offset)+i)%<span class="built_in">len</span>(potentialNodes)].Clone()</span><br><span class="line">      stateCopy := ev.State.Clone()</span><br><span class="line">      <span class="comment">//并发执行搜索，计算潜在的node中所有可以抢占的节点列表</span></span><br><span class="line">      pods, numPDBViolations, status := ev.SelectVictimsOnNode(ctx, stateCopy, pod, nodeInfoCopy, pdbs)</span><br><span class="line">      <span class="keyword">if</span> status.IsSuccess() &amp;&amp; <span class="built_in">len</span>(pods) != <span class="number">0</span> &#123;</span><br><span class="line">         victims := extenderv1.Victims&#123;</span><br><span class="line">            Pods:             pods,</span><br><span class="line">            NumPDBViolations: <span class="type">int64</span>(numPDBViolations),</span><br><span class="line">         &#125;</span><br><span class="line">         c := &amp;candidate&#123;</span><br><span class="line">            victims: &amp;victims,</span><br><span class="line">            name:    nodeInfoCopy.Node().Name,</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> numPDBViolations == <span class="number">0</span> &#123;</span><br><span class="line">            nonViolatingCandidates.add(c)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            violatingCandidates.add(c)</span><br><span class="line">         &#125;</span><br><span class="line">         nvcSize, vcSize := nonViolatingCandidates.size(), violatingCandidates.size()</span><br><span class="line">         <span class="keyword">if</span> nvcSize &gt; <span class="number">0</span> &amp;&amp; nvcSize+vcSize &gt;= numCandidates &#123;</span><br><span class="line">            cancel()</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> status.IsSuccess() &amp;&amp; <span class="built_in">len</span>(pods) == <span class="number">0</span> &#123;</span><br><span class="line">         status = framework.AsStatus(fmt.Errorf(<span class="string">&quot;expected at least one victim pod on node %q&quot;</span>, nodeInfoCopy.Node().Name))</span><br><span class="line">      &#125;</span><br><span class="line">      statusesLock.Lock()</span><br><span class="line">      <span class="keyword">if</span> status.Code() == framework.Error &#123;</span><br><span class="line">         errs = <span class="built_in">append</span>(errs, status.AsError())</span><br><span class="line">      &#125;</span><br><span class="line">      nodeStatuses[nodeInfoCopy.Node().Name] = status</span><br><span class="line">      statusesLock.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">   fh.Parallelizer().Until(parallelCtx, <span class="built_in">len</span>(potentialNodes), checkNode)</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">append</span>(nonViolatingCandidates.get(), violatingCandidates.get()...), nodeStatuses, utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>4）选择一个最佳的抢占节点</strong></p>
<p>Pod Disruption Budget(PDB)</p>
<p>pod中断预算，限制同时中断的Pod资源对象数量，以保证集群的高可用</p>
<p>选择标准(按照下列顺序进行判断，如果只有一个则不进行下一步判断，直接返回)</p>
<ol>
<li>PDB中断次数最小</li>
<li>每个节点的最高优先级中最小</li>
<li>优先级总和最小</li>
<li>Pod总数最小</li>
<li>最早开始运行的节点</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pickOneNodeForPreemption</span><span class="params">(nodesToVictims <span class="keyword">map</span>[<span class="type">string</span>]*extenderv1.Victims)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(nodesToVictims) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   minNumPDBViolatingPods := <span class="type">int64</span>(math.MaxInt32)</span><br><span class="line">   <span class="keyword">var</span> minNodes1 []<span class="type">string</span></span><br><span class="line">   lenNodes1 := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> node, victims := <span class="keyword">range</span> nodesToVictims &#123;</span><br><span class="line">   <span class="comment">//找到PDBViolations最少的node，中断次数最少的节点</span></span><br><span class="line">      numPDBViolatingPods := victims.NumPDBViolations</span><br><span class="line">      <span class="keyword">if</span> numPDBViolatingPods &lt; minNumPDBViolatingPods &#123;</span><br><span class="line">         minNumPDBViolatingPods = numPDBViolatingPods</span><br><span class="line">         minNodes1 = <span class="literal">nil</span></span><br><span class="line">         lenNodes1 = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> numPDBViolatingPods == minNumPDBViolatingPods &#123;</span><br><span class="line">         minNodes1 = <span class="built_in">append</span>(minNodes1, node)</span><br><span class="line">         lenNodes1++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到具有高优先级中最低的node</span></span><br><span class="line">	minHighestPriority := <span class="type">int32</span>(math.MaxInt32)</span><br><span class="line">	<span class="keyword">var</span> minNodes2 = <span class="built_in">make</span>([]<span class="type">string</span>, lenNodes1)</span><br><span class="line">	lenNodes2 := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">		node := minNodes1[i]</span><br><span class="line">		victims := nodesToVictims[node]</span><br><span class="line">		highestPodPriority := corev1helpers.PodPriority(victims.Pods[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> highestPodPriority &lt; minHighestPriority &#123;</span><br><span class="line">			minHighestPriority = highestPodPriority</span><br><span class="line">			lenNodes2 = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> highestPodPriority == minHighestPriority &#123;</span><br><span class="line">			minNodes2[lenNodes2] = node</span><br><span class="line">			lenNodes2++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算优先级总和最少的</span></span><br><span class="line">	minSumPriorities := <span class="type">int64</span>(math.MaxInt64)</span><br><span class="line">	lenNodes1 = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> sumPriorities <span class="type">int64</span></span><br><span class="line">		node := minNodes2[i]</span><br><span class="line">		<span class="keyword">for</span> _, pod := <span class="keyword">range</span> nodesToVictims[node].Pods &#123;</span><br><span class="line">			sumPriorities += <span class="type">int64</span>(corev1helpers.PodPriority(pod)) + <span class="type">int64</span>(math.MaxInt32+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sumPriorities &lt; minSumPriorities &#123;</span><br><span class="line">			minSumPriorities = sumPriorities</span><br><span class="line">			lenNodes1 = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sumPriorities == minSumPriorities &#123;</span><br><span class="line">			minNodes1[lenNodes1] = node</span><br><span class="line">			lenNodes1++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pod数量最少的节点</span></span><br><span class="line">	minNumPods := math.MaxInt32</span><br><span class="line">	lenNodes2 = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">		node := minNodes1[i]</span><br><span class="line">		numPods := <span class="built_in">len</span>(nodesToVictims[node].Pods)</span><br><span class="line">		<span class="keyword">if</span> numPods &lt; minNumPods &#123;</span><br><span class="line">			minNumPods = numPods</span><br><span class="line">			lenNodes2 = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> numPods == minNumPods &#123;</span><br><span class="line">			minNodes2[lenNodes2] = node</span><br><span class="line">			lenNodes2++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 到这一步选择，选择最早开始运行的node</span></span><br><span class="line">	latestStartTime := util.GetEarliestPodStartTime(nodesToVictims[minNodes2[<span class="number">0</span>]])</span><br><span class="line">	<span class="keyword">if</span> latestStartTime == <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(errors.New(<span class="string">&quot;earliestStartTime is nil for node&quot;</span>), <span class="string">&quot;Should not reach here&quot;</span>, <span class="string">&quot;node&quot;</span>, klog.KRef(<span class="string">&quot;&quot;</span>, minNodes2[<span class="number">0</span>]))</span><br><span class="line">		<span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	nodeToReturn := minNodes2[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">		node := minNodes2[i]</span><br><span class="line">		earliestStartTimeOnNode := util.GetEarliestPodStartTime(nodesToVictims[node])</span><br><span class="line">		<span class="keyword">if</span> earliestStartTimeOnNode == <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(errors.New(<span class="string">&quot;earliestStartTime is nil for node&quot;</span>), <span class="string">&quot;Should not reach here&quot;</span>, <span class="string">&quot;node&quot;</span>, klog.KRef(<span class="string">&quot;&quot;</span>, node))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> earliestStartTimeOnNode.After(latestStartTime.Time) &#123;</span><br><span class="line">			latestStartTime = earliestStartTimeOnNode</span><br><span class="line">			nodeToReturn = node</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nodeToReturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-5-bind机制"><a href="#6-5-bind机制" class="headerlink" title="6-5 bind机制"></a>6-5 bind机制</h3><p>调度器通过ClientSet()向API Server发送binding资源对象，绑定成功则调度周期结束，运行pod资源交给node上的kubelet</p>
<p>bind过程是异步的，不需要等待bind操作完成就可以开始下一次调度</p>
<p>对应的也是以插件形式对bind策略进行定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BindPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   Bind(ctx context.Context, state *CycleState, p *v1.Pod, nodeName <span class="type">string</span>) *Status</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b DefaultBinder)</span></span> Bind(ctx context.Context, state *framework.CycleState, p *v1.Pod, nodeName <span class="type">string</span>) *framework.Status &#123;</span><br><span class="line">   klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Attempting to bind pod to node&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(p), <span class="string">&quot;node&quot;</span>, klog.KRef(<span class="string">&quot;&quot;</span>, nodeName))</span><br><span class="line">   binding := &amp;v1.Binding&#123;</span><br><span class="line">      ObjectMeta: metav1.ObjectMeta&#123;Namespace: p.Namespace, Name: p.Name, UID: p.UID&#125;,</span><br><span class="line">      Target:     v1.ObjectReference&#123;Kind: <span class="string">&quot;Node&quot;</span>, Name: nodeName&#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   err := b.handle.ClientSet().CoreV1().Pods(binding.Namespace).Bind(ctx, binding, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> framework.AsStatus(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-选举机制"><a href="#6-6-选举机制" class="headerlink" title="6-6 选举机制"></a>6-6 选举机制</h3><p>kube-scheduler节点中只有leader能够运行，其他节点阻塞</p>
<p>分布式锁</p>
<p>锁依赖于etcd中的一个key</p>
<p>锁的状态：</p>
<p>不存在：一个节点成功创建，则为leader，leader会定时更新(续约)该key的信息</p>
<p>存在：其余节点阻塞并定时获取锁，验证锁是否到期，到期了可以尝试写入自己的信息，更新成功的节点作为leader</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LeaderElectionRecord <span class="keyword">struct</span> &#123;</span><br><span class="line">   HolderIdentity       <span class="type">string</span>      <span class="string">`json:&quot;holderIdentity&quot;`</span>  <span class="comment">//leader身份标识</span></span><br><span class="line">   LeaseDurationSeconds <span class="type">int</span>         <span class="string">`json:&quot;leaseDurationSeconds&quot;`</span> <span class="comment">//leader租约时长</span></span><br><span class="line">   AcquireTime          metav1.Time <span class="string">`json:&quot;acquireTime&quot;`</span><span class="comment">//leader获取锁的时间</span></span><br><span class="line">   RenewTime            metav1.Time <span class="string">`json:&quot;renewTime&quot;`</span><span class="comment">//leader续租时间</span></span><br><span class="line">   LeaderTransitions    <span class="type">int</span>         <span class="string">`json:&quot;leaderTransitions&quot;`</span><span class="comment">//leader选举切换次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>选举</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func (le *LeaderElector) Run(ctx context.Context) &#123;</span><br><span class="line">   defer runtime.HandleCrash()</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      le.config.Callbacks.OnStoppedLeading()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   if !le.acquire(ctx) &#123;</span><br><span class="line">      return // ctx signalled done</span><br><span class="line">   &#125;</span><br><span class="line">   ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">   defer cancel()</span><br><span class="line">   go le.config.Callbacks.OnStartedLeading(ctx)</span><br><span class="line">   le.renew(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>1、资源锁获取</strong></p>
<p>wait.JitterUntil 定时器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *LeaderElector)</span></span> acquire(ctx context.Context) <span class="type">bool</span> &#123;</span><br><span class="line">   ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">   <span class="keyword">defer</span> cancel()</span><br><span class="line">   succeeded := <span class="literal">false</span></span><br><span class="line">   desc := le.config.Lock.Describe()</span><br><span class="line">   klog.Infof(<span class="string">&quot;attempting to acquire leader lease %v...&quot;</span>, desc)</span><br><span class="line">   wait.JitterUntil(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      succeeded = le.tryAcquireOrRenew(ctx)</span><br><span class="line">      le.maybeReportTransition()</span><br><span class="line">      <span class="keyword">if</span> !succeeded &#123;</span><br><span class="line">         klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;failed to acquire lease %v&quot;</span>, desc)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      le.config.Lock.RecordEvent(<span class="string">&quot;became leader&quot;</span>)</span><br><span class="line">      le.metrics.leaderOn(le.config.Name)</span><br><span class="line">      klog.Infof(<span class="string">&quot;successfully acquired lease %v&quot;</span>, desc)</span><br><span class="line">      cancel()</span><br><span class="line">   &#125;, le.config.RetryPeriod, JitterFactor, <span class="literal">true</span>, ctx.Done())</span><br><span class="line">   <span class="keyword">return</span> succeeded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *LeaderElector)</span></span> tryAcquireOrRenew(ctx context.Context) <span class="type">bool</span> &#123;</span><br><span class="line">	now := metav1.Now()</span><br><span class="line">	leaderElectionRecord := rl.LeaderElectionRecord&#123;</span><br><span class="line">		HolderIdentity:       le.config.Lock.Identity(),</span><br><span class="line">		LeaseDurationSeconds: <span class="type">int</span>(le.config.LeaseDuration / time.Second),</span><br><span class="line">		RenewTime:            now,</span><br><span class="line">		AcquireTime:          now,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 获取资源锁，如果不存在则尝试创建，创建成功则获取锁成功，leader选举成功</span></span><br><span class="line">	oldLeaderElectionRecord, oldLeaderElectionRawRecord, err := le.config.Lock.Get(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">			klog.Errorf(<span class="string">&quot;error retrieving resource lock %v: %v&quot;</span>, le.config.Lock.Describe(), err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err = le.config.Lock.Create(ctx, leaderElectionRecord); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">&quot;error initially creating leader election record: %v&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		le.setObservedRecord(&amp;leaderElectionRecord)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. Record obtained, check the Identity &amp; Time</span></span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(le.observedRawRecord, oldLeaderElectionRawRecord) &#123;</span><br><span class="line">		le.setObservedRecord(oldLeaderElectionRecord)</span><br><span class="line"></span><br><span class="line">		le.observedRawRecord = oldLeaderElectionRawRecord</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//存在leader，当前节点不是leader，且leader租约未到期，获取锁失败</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(oldLeaderElectionRecord.HolderIdentity) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		le.observedTime.Add(le.config.LeaseDuration).After(now.Time) &amp;&amp;</span><br><span class="line">		!le.IsLeader() &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;lock is held by %v and has not yet expired&quot;</span>, oldLeaderElectionRecord.HolderIdentity)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 更新本节点上的leaderElectionRecord</span></span><br><span class="line">	<span class="keyword">if</span> le.IsLeader() &#123;</span><br><span class="line">        <span class="comment">//当前leader未进行切换，续约成功</span></span><br><span class="line">		leaderElectionRecord.AcquireTime = oldLeaderElectionRecord.AcquireTime</span><br><span class="line">		leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//走到这里说明租约到期了，新的选举进行了leader切换，因此切换次数+1</span></span><br><span class="line">		leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4、更新锁资源</span></span><br><span class="line">	<span class="keyword">if</span> err = le.config.Lock.Update(ctx, leaderElectionRecord); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;Failed to update lock: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	le.setObservedRecord(&amp;leaderElectionRecord)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>2、leader的租约续期</strong></p>
<p>wait.PollImmediateUntil 定时器定时执行续约 默认为2s</p>
<p>续约过程还是调用上述资源锁获取函数进行续约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func (le *LeaderElector) renew(ctx context.Context) &#123;</span><br><span class="line">   ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">   defer cancel()</span><br><span class="line">   wait.Until(func() &#123;</span><br><span class="line">      timeoutCtx, timeoutCancel := context.WithTimeout(ctx, le.config.RenewDeadline)</span><br><span class="line">      defer timeoutCancel()</span><br><span class="line">      err := wait.PollImmediateUntil(le.config.RetryPeriod, func() (bool, error) &#123;</span><br><span class="line">         return le.tryAcquireOrRenew(timeoutCtx), nil</span><br><span class="line">      &#125;, timeoutCtx.Done())</span><br><span class="line"></span><br><span class="line">      le.maybeReportTransition()</span><br><span class="line">      desc := le.config.Lock.Describe()</span><br><span class="line">      if err == nil &#123;</span><br><span class="line">         klog.V(5).Infof(&quot;successfully renewed lease %v&quot;, desc)</span><br><span class="line">         return</span><br><span class="line">      &#125;</span><br><span class="line">      le.config.Lock.RecordEvent(&quot;stopped leading&quot;)</span><br><span class="line">      le.metrics.leaderOff(le.config.Name)</span><br><span class="line">      klog.Infof(&quot;failed to renew lease %v: %v&quot;, desc, err)</span><br><span class="line">      cancel()</span><br><span class="line">   &#125;, le.config.RetryPeriod, ctx.Done())</span><br><span class="line"></span><br><span class="line">   // if we hold the lease, give it up</span><br><span class="line">   if le.config.ReleaseOnCancel &#123;</span><br><span class="line">      le.release()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WW</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
